---
name: 'Nextflow tests'

on:
  workflow_call:

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.sha }}
  cancel-in-progress: true

# Inspired by https://blog.aspect.dev/github-actions-dynamic-matrix
jobs:
  discover:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        name: Parse event
        id: parse-event
        with:
          script: |
            /*
            We need to determine if the incoming event was from a pull_request
            or an issue_comment
            */
            let apply_fixes = context.eventName == 'issue_comment'

            let pr = {}

            if (apply_fixes) {
              // React to the original comment
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: "rocket"
              })

              // Get the pull request context
              pr = (await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.issue.number
              })).data
            } else {
              pr = context.payload.pull_request
            }

            core.setOutput('apply_fixes', apply_fixes)
            core.setOutput('checkout_ref', `refs/pull/${pr.number}/merge`)
            core.setOutput('branch_ref', pr.head.ref)
            core.setOutput('review_sha', pr.head.sha)
            core.setOutput('pr_number', pr.number)

      - uses: actions/checkout@v4
        with:
          ref: ${{ steps.parse-event.outputs.checkout_ref }}

      - id: listfiles
        shell: python
        run: |
          import json
          import os
          from pathlib import Path

          testfiles = [
              str(item) for item in
              Path(".").glob("**/configtest*.json")
          ]
          with open(os.environ.get("GITHUB_OUTPUT"),
                  mode="w", encoding="utf-8") as outfile:
              outfile.write(f"testfiles={json.dumps(testfiles)}\n")
              outfile.write(f"num_tests={json.dumps(bool(testfiles))}\n")

    outputs:
      testfiles: ${{ steps.listfiles.outputs.testfiles }}
      num_tests: ${{ steps.listfiles.outputs.num_tests }}
      apply_fixes: ${{ steps.parse-event.outputs.apply_fixes }}
      checkout_ref: ${{ steps.parse-event.outputs.checkout_ref }}
      branch_ref: ${{ steps.parse-event.outputs.branch_ref }}
      review_sha: ${{ steps.parse-event.outputs.review_sha }}
      pr_number: ${{ steps.parse-event.outputs.pr_number }}

  run:
    runs-on: ubuntu-latest
    needs: discover
    if: ${{ fromJSON(needs.discover.outputs.num_tests) }}

    strategy:
      fail-fast: false
      matrix:
        testfile: ${{ fromJSON(needs.discover.outputs.testfiles) }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.discover.outputs.checkout_ref }}
          submodules: true

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - id: dockertest
        run: |
          docker run \
            --rm \
            -e CI \
            -e GITHUB_OUTPUT \
            -v "$GITHUB_OUTPUT:$GITHUB_OUTPUT" \
            -v ${{ github.workspace}}:${{ github.workspace }} \
            -w ${{ github.workspace }} \
            ghcr.io/uclahs-cds/nextflow-config-tests:autofix-dev \
              ${{ github.workspace }} \
              ${{ matrix.testfile }}

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.dockertest.outputs.archive_key }}
          path: ${{ steps.dockertest.outputs.archive_path }}
        if: ${{ !cancelled() }}

  summary:
    runs-on: ubuntu-latest
    needs: [run, discover]
    if: ${{ !cancelled() }}

    steps:
      - uses: actions/github-script@v7
        id: status
        name: Determine required steps
        with:
          script: |
            var needs = ${{ toJSON(needs) }}
            var tests_failed = needs.run.result != 'success' &&
              needs.run.result != 'skipped'

            var should_comment = tests_failed &&
                !(needs.discover.outputs.apply_fixes == 'true')

            var should_fix = tests_failed &&
                (needs.discover.outputs.apply_fixes == 'true')

            // Find the most recent open review from the bot, as well as all of
            // the comments
            let review_id = -1
            let comments = []

            /*
            As far as I can tell, this is fixed... I wish I could figure out
            how to infer this from the token. The users.getAuthenticated()
            endpoint throws "HttpError: Resource not accessible by integration",
            and GITHUB_ACTOR / GITHUB_ACTOR_ID / GITHUB_TRIGGERING_ACTOR refer
            to the real user (not the bot).
            */
            let bot_id = 41898282

            console.log(needs.discover.outputs)

            for await (const response of github.paginate.iterator(
              github.rest.pulls.listReviews,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: needs.discover.outputs.pr_number
              }
            )) {
              for (const review of response.data) {
                if (review.user.id == bot_id) {
                  comments.push(review.body)
                  console.log(`Prior review: ${review.body}`)

                  if (review.state == "CHANGES_REQUESTED") {
                    // Save the newest review ID
                    review_id = review.id
                  } else if (review.state == "DISMISSED") {
                    // Dismissals implicitly dismiss all prior reviews
                    review_id = -1
                  }
                }
              }
            }

            if (!should_fix && review_id != -1) {
              // There is an open review but the problems are resolved
              await github.rest.pulls.dismissReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: needs.discover.outputs.pr_number,
                review_id: review_id,
                message: "All tests are passing!"
              })
            }

            core.setOutput('tests-failed', tests_failed)
            core.setOutput('should-comment', should_comment)
            core.setOutput('should-fix', should_fix)
            core.setOutput('comments', comments)

      - if: ${{ steps.status.outputs.tests-failed == 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.discover.outputs.checkout_ref }}
          # By default the depth is 1, which only fetches the current commit
          # with no history. Instead fetch all history so we can compare it to
          # the base branch. There doesn't seem to be any middle ground ("get
          # everything between the two commits").
          fetch-depth: 0

      - if: ${{ steps.status.outputs.tests-failed == 'true' }}
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true

      - if: ${{ steps.status.outputs.should-comment == 'true' }}
        id: createreview
        name: Post review
        uses: actions/github-script@v7
        with:
          script: |
            const fsPromises = require('fs/promises')

            // Get the list of all annotation files
            const annotation_files = (await exec.getExecOutput(
              'git',
              ['ls-files', '--others', '--exclude-standard', '--', '*.prnote'],
            )).stdout.trim().split(/\r?\n/)

            let prefix = "Alas, some of the Nextflow configuration tests failed"

            let comments = ${{ toJSON(steps.status.outputs.comments) }}

            if (!comments.length || !comments[comments.length-1].includes(prefix)) {
              let body = `*Bleep bloop, I am a robot.*\n\n${ prefix }!`

              const notes = await Promise.all(annotation_files.map(filename =>
                fsPromises.readFile(filename, {encoding: 'utf-8'})
              ))

              let suffix = `There are two ways to fix this:

            1. **Manually**: Follow [these steps](https://uclahs-cds.atlassian.net/wiki/spaces/BOUTROSLAB/pages/254115842/Nextflow+Configuration+Regression+Tests#Resolving-Pull-Request-Check-Failures) on Confluence.
            2. **Automatically**: Post a comment starting with "/fix-tests" (without the quotes) I will update the tests for you (you should review my work afterwards).`

              github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                commit_id: ${{ toJSON(needs.discover.outputs.review_sha) }},
                event: "REQUEST_CHANGES",
                body: [body, ...notes, suffix].join("\n")
              })
            } else {
              console.log("Still can't fix anything")
            }

      - if: ${{ steps.status.outputs.should-fix == 'true' }}
        id: pushchanges
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: Autofix Nextflow configuration regression tests
          branch: ${{ needs.discover.outputs.branch_ref }}
          file_pattern: '**/configtest*.json'
